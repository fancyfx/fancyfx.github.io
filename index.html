<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="能讲清楚你不会的知识，才代表正真学会了！">
<meta property="og:type" content="website">
<meta property="og:title" content="Fancyxi的博客">
<meta property="og:url" content="https://fancyfx.github.io/index.html">
<meta property="og:site_name" content="Fancyxi的博客">
<meta property="og:description" content="能讲清楚你不会的知识，才代表正真学会了！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fancyxi的博客">
<meta name="twitter:description" content="能讲清楚你不会的知识，才代表正真学会了！">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6278229309505144000,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://fancyfx.github.io/"/>

  <title> Fancyxi的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Fancyxi的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-demo">
          <a href="/demo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sticky-note"></i> <br />
            
            deom
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/15/2016/2016-11-15-promise学习笔记/" itemprop="url">
                  JavaScript异步操作之Promise学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-15T23:23:00+08:00" content="2016-11-15">
              2016-11-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/15/2016/2016-11-15-promise学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/15/2016/2016-11-15-promise学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h1><p>  简单来说的<code>Promise</code>是一个异步处理规范，在JS中我们可以把他理解为一个异步处理函数，使用Promise规范的异步处理流程和方法来进行异步处理。<br>目前<code>Promise</code>还在<a href="https://tc39.github.io/ecma262/#sec-promise-objects" target="_blank" rel="external">ES6 Promises</a>规范草案阶段。</p>
<h1 id="Promise浏览器兼容性"><a href="#Promise浏览器兼容性" class="headerlink" title="Promise浏览器兼容性"></a>Promise浏览器兼容性</h1><p><img src="../../img/Snip20161120_1.png" alt="  浏览器兼容性"></p>
<h1 id="Promise主要API"><a href="#Promise主要API" class="headerlink" title="Promise主要API"></a>Promise主要API</h1><h2 id="常用方法-promise-then-和-promise-catch"><a href="#常用方法-promise-then-和-promise-catch" class="headerlink" title="常用方法 promise.then() 和 promise.catch()"></a>常用方法 <code>promise.then()</code> 和 <code>promise.catch()</code></h2><p>  使用Promise简单的来说可以分为三步</p>
<h3 id="①-通过new实例化Promise对象，并设置其值在-resolve-成功-reject-失败-时调用的回调函数"><a href="#①-通过new实例化Promise对象，并设置其值在-resolve-成功-reject-失败-时调用的回调函数" class="headerlink" title="① 通过new实例化Promise对象，并设置其值在 resolve(成功) / reject(失败)时调用的回调函数"></a>① 通过<code>new</code>实例化<code>Promise</code>对象，并设置其值在 resolve(成功) / reject(失败)时调用的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 要想创建一个promise对象、可以使用new来调用Promise的构造器来进行实例化。</div><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">    // 异步处理</div><div class="line">    // 处理结束后、调用resolve 或 reject</div><div class="line">    //对通过new生成的promise对象为了设置其值在 resolve(成功) / reject(失败)时调用的回调函数</div><div class="line">    if (err) &#123;</div><div class="line">      reject(&apos;error&apos;);</div><div class="line">    &#125;else&#123;</div><div class="line">      resolve(&apos;ok&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="②-如果成功-那么通过-promise-then-方法捕获成功的回调函数"><a href="#②-如果成功-那么通过-promise-then-方法捕获成功的回调函数" class="headerlink" title="② 如果成功 那么通过 promise.then()方法捕获成功的回调函数"></a>② 如果成功 那么通过 <code>promise.then()</code>方法捕获成功的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 如果成功 那么 promise.then()方法会执行</div><div class="line">promise.then(function(value)&#123;</div><div class="line">  console.log(value); // ok</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h3 id="③-如果失败-那么通过-promise-catch-方法捕获失败的回调函数"><a href="#③-如果失败-那么通过-promise-catch-方法捕获失败的回调函数" class="headerlink" title="③ 如果失败 那么通过 promise.catch()方法捕获失败的回调函数"></a>③ 如果失败 那么通过 <code>promise.catch()</code>方法捕获失败的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 如果失败 那么 promise.catch()方法会执行</div><div class="line">promise.catch(function(value)&#123;</div><div class="line">  console.log(value); // error</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="promise-then-实例方法的参数"><a href="#promise-then-实例方法的参数" class="headerlink" title="promise.then()实例方法的参数"></a><code>promise.then()</code>实例方法的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p><strong>resolve(成功)时</strong><br>onFulfilled 会被调用</p>
<p><strong>reject(失败)时</strong><br>onRejected 会被调用<br>onFulfilled、onRejected 两个都为可选参数。</p>
<p><strong>promise.then 成功和失败时都可以使用</strong>。<br><code>promise.then(undefined, onRejected)</code> 这种方式 等价于<code>promise.catch(onRejected)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//不使用catch 方法只使用 then方法的话,如下所示的代码也能完成相同的工作</div><div class="line">promise.then(function (value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;, function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>不过大部分情况下使用 <code>promise.catch(onRejected)</code>处理异常 应该是个更好的选择。</p>
<h2 id="new-Promise的快捷方式"><a href="#new-Promise的快捷方式" class="headerlink" title="new Promise的快捷方式"></a>new Promise的快捷方式</h2><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a><code>Promise.resolve(value)</code></h3><p>静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。</p>
<p>比如 Promise.resolve(42); 可以认为是以下代码的语法糖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>方法 Promise.resolve(value); 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(42).then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Promise-reject-error"><a href="#Promise-reject-error" class="headerlink" title="Promise.reject(error)"></a><code>Promise.reject(error)</code></h3><p>Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">    reject(new Error(&quot;出错了&quot;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码的功能是调用该promise对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.reject(new Error(&quot;BOOM!&quot;)).catch(function(error)&#123;</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h2><p><code>Promise.all</code>接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 <code>.then</code> 方法。</p>
<p>如果像下面那样使用一个计时器来计算一下程序执行时间的话，那么就可以非常清楚的知道传递给 Promise.all 的promise数组是同时开始执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// `delay`毫秒后执行resolve</div><div class="line">function timerPromisefy(delay) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(delay);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">var startDate = Date.now();</div><div class="line">// 所有promise变为resolve后程序退出</div><div class="line">Promise.all([</div><div class="line">    timerPromisefy(1),</div><div class="line">    timerPromisefy(32),</div><div class="line">    timerPromisefy(64),</div><div class="line">    timerPromisefy(128)</div><div class="line">]).then(function (values) &#123;</div><div class="line">    console.log(Date.now() - startDate + &apos;ms&apos;);</div><div class="line">    // 約128ms</div><div class="line">    console.log(values);    // [1,32,64,128]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h2><p>和 <code>Promise.all</code> 类似的对多个promise对象进行处理的 <code>Promise.race</code> 方法。</p>
<p>它的使用方法和P<code>romise.all</code>一样，接收一个promise对象数组为参数。</p>
<p><code>Promise.all</code> 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理， 与之相对的是 <code>Promise.race</code> 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
<p>像Promise.all时的例子一样，我们来看一个带计时器的 Promise.race 的使用例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// `delay`毫秒后执行resolve</div><div class="line">function timerPromisefy(delay) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(delay);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// 任何一个promise变为resolve或reject 的话程序就停止运行</div><div class="line">Promise.race([</div><div class="line">    timerPromisefy(1),</div><div class="line">    timerPromisefy(32),</div><div class="line">    timerPromisefy(64),</div><div class="line">    timerPromisefy(128)</div><div class="line">]).then(function (value) &#123;</div><div class="line">    console.log(value);    // =&gt; 1</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>注意<code>Promise.race</code> 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</strong></p>
<h1 id="应用-XHR请求超时机制"><a href="#应用-XHR请求超时机制" class="headerlink" title="应用 XHR请求超时机制"></a>应用 XHR请求超时机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">// 虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是普通的错误还是超时错误了。</div><div class="line"></div><div class="line">// 为了能区分这个 Error 对象的类型，我们再来定义一个Error 对象的子类 TimeoutError。</div><div class="line">// ③定制Error对象</div><div class="line">function copyOwnFrom(target, source) &#123;</div><div class="line">    Object.getOwnPropertyNames(source).forEach(function (propName) &#123;</div><div class="line">        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));</div><div class="line">    &#125;);</div><div class="line">    return target;</div><div class="line">&#125;</div><div class="line">function TimeoutError() &#123;</div><div class="line">    var superInstance = Error.apply(null, arguments);</div><div class="line">    copyOwnFrom(this, superInstance);</div><div class="line">&#125;</div><div class="line">TimeoutError.prototype = Object.create(Error.prototype);</div><div class="line">TimeoutError.prototype.constructor = TimeoutError;</div><div class="line"></div><div class="line">// Promise.race 来是实现简单的超时机制</div><div class="line">// ①让Promise等待指定时间</div><div class="line">function delayPromise(ms) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(resolve, ms);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// ② Promise.race中的超时操作</div><div class="line">function timeoutPromise(promise, ms) &#123;</div><div class="line">    var timeout = delayPromise(ms).then(function () &#123;</div><div class="line">            return Promise.reject(new TimeoutError(&apos;Operation timed out after &apos; + ms + &apos; ms&apos;));</div><div class="line">        &#125;);</div><div class="line">    return Promise.race([promise, timeout]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过 cancelableXHR 方法取得包装了XHR的promise对象和取消该XHR请求的方法</div><div class="line">// ④ 通过超时取消XHR操作</div><div class="line">function cancelableXHR(URL) &#123;</div><div class="line">    var req = new XMLHttpRequest();</div><div class="line">    var promise = new Promise(function (resolve, reject) &#123;</div><div class="line">            req.open(&apos;GET&apos;, URL, true);</div><div class="line">            req.onload = function () &#123;</div><div class="line">                if (req.status === 200) &#123;</div><div class="line">                    resolve(req.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                    reject(new Error(req.statusText));</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            req.onerror = function () &#123;</div><div class="line">                reject(new Error(req.statusText));</div><div class="line">            &#125;;</div><div class="line">            req.onabort = function () &#123;</div><div class="line">                reject(new Error(&apos;abort this request&apos;));</div><div class="line">            &#125;;</div><div class="line">            req.send();</div><div class="line">        &#125;);</div><div class="line">    var abort = function () &#123;</div><div class="line">        // 如果request还没有结束的话就执行abort</div><div class="line">        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</div><div class="line">        if (req.readyState !== XMLHttpRequest.UNSENT) &#123;</div><div class="line">            req.abort();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return &#123;</div><div class="line">        promise: promise,</div><div class="line">        abort: abort</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var object = cancelableXHR(&apos;http://httpbin.org/get&apos;);</div><div class="line">// main</div><div class="line">timeoutPromise(object.promise, 1000).then(function (contents) &#123;</div><div class="line">    console.log(&apos;Contents&apos;, contents);</div><div class="line">&#125;).catch(function (error) &#123;</div><div class="line">    if (error instanceof TimeoutError) &#123;</div><div class="line">        object.abort();</div><div class="line">        return console.log(error);</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;XHR Error :&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Promise的实现类库（Library）"><a href="#Promise的实现类库（Library）" class="headerlink" title="Promise的实现类库（Library）"></a>Promise的实现类库（Library）</h1><p>在这些Promise的实现类库中，我们这里主要对两种类型的类库进行介绍。</p>
<p>一种是被称为 Polyfill （这是一款英国产品，就是装修刮墙用的腻子，其意义可想而知 — 译者注）的类库，另一种是即具有 Promises/A+兼容性 ，又增加了自己独特功能的类库。</p>
<h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">jakearchibald/es6-promise</a></p>
<blockquote>
<p>一个兼容 ES6 Promises 的Polyfill类库。 它基于 RSVP.js 这个兼容 Promises/A+ 的类库， 它只是 RSVP.js 的一个子集，只实现了Promises 规定的 API。</p>
</blockquote>
<p><a href="https://github.com/yahoo/ypromise" target="_blank" rel="external">yahoo/ypromise</a></p>
<blockquote>
<p>这是一个独立版本的 YUI 的 Promise Polyfill，具有和 ES6 Promises 的兼容性。 本书的示例代码也都是基于这个 ypromise 的 Polyfill 来在线运行的。</p>
</blockquote>
<p><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="external">getify/native-promise-only</a></p>
<blockquote>
<p>以作为ES6 Promises的polyfill为目的的类库 它严格按照ES6 Promises的规范设计，没有添加在规范中没有定义的功能。 如果运行环境有原生的Promise支持的话，则优先使用原生的Promise支持。</p>
</blockquote>
<h2 id="Promise扩展类库"><a href="#Promise扩展类库" class="headerlink" title="Promise扩展类库"></a>Promise扩展类库</h2><p><a href="https://github.com/kriskowal/q" target="_blank" rel="external">kriskowal/q</a></p>
<blockquote>
<p>类库 <code>Q</code> 实现了 Promises 和 Deferreds 等规范。 它自2009年开始开发，还提供了面向Node.js的文件IO API Q-IO 等， 是一个在很多场景下都能用得到的类库。</p>
</blockquote>
<p><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">petkaantonov/bluebird</a></p>
<blockquote>
<p>这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a>(首推 简单易懂 本文就是根据这本电子书的内容整理而成)<br><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">We have a problem with promises</a>（进阶）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/09/2016/2016-08-09-javascript模块化/" itemprop="url">
                  JavaScript模块化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-09T02:59:00+08:00" content="2016-08-09">
              2016-08-09
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/09/2016/2016-08-09-javascript模块化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/09/2016/2016-08-09-javascript模块化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="为什么要有模块化？"><a href="#为什么要有模块化？" class="headerlink" title="为什么要有模块化？"></a>为什么要有模块化？</h2><p>我先讲个故事：某公司开发一个项目，刚开始项目比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;b.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;c.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">// 只有三个功能 a,b,c 但是b依赖于a c依赖于b</div><div class="line">// 所以刚开始是这样引入文件的</div></pre></td></tr></table></figure></p>
<p>后来项目变复杂了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;b.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;c.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;a-1.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;b-1.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;c-1.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">// 加入的更多功能</div><div class="line">// 且依赖关系变的更复杂了 (——&gt; 依赖于)</div><div class="line">//  a-1 ——&gt; a &amp;&amp; b</div><div class="line">//  b-1 ——&gt; b &amp;&amp; a-1</div><div class="line">//  c-1 ——&gt; b &amp;&amp; a-1 &amp;&amp; c</div></pre></td></tr></table></figure></p>
<p>是不是发现上面的依赖关系变得很复杂了，如果项目越来越大，我的天那这些引入文件的依赖关系，想想都头疼。</p>
<p>怎么办了？于是出现一个模块化的方式来引入文件，想要什么功能，就加载什么模块。</p>
<h2 id="实现模块化的方式"><a href="#实现模块化的方式" class="headerlink" title="实现模块化的方式"></a>实现模块化的方式</h2><p>但是，Javascript模块没有官方规范。<br>所以出现几种比较通用的模块化规范：<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>、<a href="http://seajs.org/docs/#intro">CMD</a><br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/09/2016/2016-08-09-javascript模块化/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/24/2016/2016-07-24-web本地存储之Storage(DOM存储)/" itemprop="url">
                  web本地存储之Storage(DOM存储)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-24T00:46:00+08:00" content="2016-07-24">
              2016-07-24
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/24/2016/2016-07-24-web本地存储之Storage(DOM存储)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/24/2016/2016-07-24-web本地存储之Storage(DOM存储)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-什么是Storage？"><a href="#1-什么是Storage？" class="headerlink" title="1. 什么是Storage？"></a>1. 什么是Storage？</h2><p>  Storage又叫DOM存储，是W3C Web存储规范里面的一种。DOM存储被设计为用来提供一个更大存储量,更安全,更便捷的存储方法,从而可以代替掉将一些不需要让服务器知道的信息存储到cookies里的这种传统方法。</p>
<p>  本文主要介绍Storage 最主要的2个对象<code>sessionStorage</code>和<code>localStorage</code>。<br>  他们是在HTM5中引入的2个新的存储对象，都是Storage构造函数实例化出来的2个window全局对象。</p>
<h2 id="2-与cookies的异同点"><a href="#2-与cookies的异同点" class="headerlink" title="2. 与cookies的异同点"></a>2. 与cookies的异同点</h2><p>  相同点：都是以建值对的的形式存储一段字符串</p>
<p>  不同点：</p>
<ul>
<li>存储时间和存储大小上限不一样</li>
<li><code>cookies</code>通常需要频繁和服务器保持通信，而<code>sessionStorage</code>和<code>localStorage</code>通常保存在本地作为本地数据使用。</li>
</ul>
<h2 id="3-sessionStorage和localStorage使用介绍"><a href="#3-sessionStorage和localStorage使用介绍" class="headerlink" title="3. sessionStorage和localStorage使用介绍"></a>3. <code>sessionStorage</code>和<code>localStorage</code>使用介绍</h2><h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1 用法"></a>3.1 用法</h3><p>  一张图看懂如何使用这2个全局对象</p>
<p><img src="/img/storage/usage.png" alt="使用方法"></p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/24/2016/2016-07-24-web本地存储之Storage(DOM存储)/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016/2016-07-23-livereload/" itemprop="url">
                  前度自动刷新工具liveReload
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T19:01:00+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/2016/2016-07-23-livereload/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/2016/2016-07-23-livereload/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="什么是liveReload？"><a href="#什么是liveReload？" class="headerlink" title="什么是liveReload？"></a>什么是liveReload？</h1><p>livereload是一个web开发辅助工具，当我们修改完html、css和js的时候会自动刷新浏览器，不需要再F5了。这样在双屏切图、写js代码的时候会提高很多效率；</p>
<p><strong>就是说有了这玩意你不用手动刷新了，是不是很爽？</strong></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><blockquote>
<p>由于我的开发机是 mac 所以以下操作都是基于mac os</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>注意：由于我使用的是 npm进行安装 且需要配合Chrome插件进行使用 因此如果你没有安装node.js和无法翻墙安装Chrome插件  下面的操作你可能无法生效</p>
</blockquote>
<p>1.使用如下命令安装  LiveReload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i livereload -g</div></pre></td></tr></table></figure></p>
<p>2.安装 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">下载地址</a><br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/23/2016/2016-07-23-livereload/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016/2016-07-23-canvas 在IE8的降级兼容方案/" itemprop="url">
                  canvas 在IE8的降级兼容方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T16:36:00+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/2016/2016-07-23-canvas 在IE8的降级兼容方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/2016/2016-07-23-canvas 在IE8的降级兼容方案/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在做基于Chart.js的数据可视化图表展示，被要求需要兼容到IE8。<br>经过搜索发现了google这个开源项目<a href="https://github.com/arv/explorercanvas" target="_blank" rel="external">ExplorerCanvas</a><br>IE8及以下的浏览器上不兼容canvas，可以使用ExplorerCanvas做兼容性的替代。</p>
</blockquote>
<h2 id="兼容性检测"><a href="#兼容性检测" class="headerlink" title="兼容性检测"></a>兼容性检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var canvasSupported = !!document.createElement(&apos;canvas&apos;).getContext;</div></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>excanvas的例子中是这样使用的：</p>
<p>#在html的<code>&lt;head&gt;&lt;/head&gt;</code>内引入所有的js</p>
<p>#在html中的<code>&lt;body&gt;</code>的<code>onload</code>上绑定canvas绘图的初始方法</p>
<p>#禁用动画<code>new Chart(ctx).Line(dataLine, {animation: false});</code><br>经过测试，发现：</p>
<p>#<code>canvas</code>标签必须写在<code>excanvas</code>初始方法之后，即：<code>canvas</code>必须在<code>excanvas</code>初始完成后生成</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/chartjs/Chart.js/issues/477" target="_blank" rel="external">Error on IE7 and IE8, Object doesn’t support property or method ‘measureText’</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016/2016-07-23-简单的点击非当前区域隐藏元素实现/" itemprop="url">
                  简单的点击非当前区域隐藏元素实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T15:15:00+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/2016/2016-07-23-简单的点击非当前区域隐藏元素实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/2016/2016-07-23-简单的点击非当前区域隐藏元素实现/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我们都遇到过这样的需求，下面是一种我觉得比较简单的实现。直接看代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(document).mouseup(function(e)&#123;</div><div class="line">  var _con = $(&apos; 目标区域 &apos;);   // 设置目标区域</div><div class="line">  if(!_con.is(e.target) &amp;&amp; _con.has(e.target).length === 0)&#123; // Mark 1</div><div class="line">    some code...   // 功能代码</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">/* Mark 1 的原理：</div><div class="line">判断点击事件发生在区域外的条件是：</div><div class="line">1. 点击事件的对象不是目标区域本身</div><div class="line">2. 事件对象同时也不是目标区域的子元素</div><div class="line">*/</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016/2016-07-23-ajax笔记/" itemprop="url">
                  Ajax笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T14:37:00+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/2016/2016-07-23-ajax笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/2016/2016-07-23-ajax笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="创建Ajax的过程"><a href="#创建Ajax的过程" class="headerlink" title="创建Ajax的过程"></a>创建Ajax的过程</h1><ul>
<li><p>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>
</li>
<li><p>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>
</li>
<li><p>设置响应HTTP请求状态变化的函数.</p>
</li>
<li><p>发送HTTP请求.</p>
</li>
<li><p>获取异步调用返回的数据.</p>
</li>
<li><p>使用JavaScript和DOM实现局部刷新.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = function () &#123;</div><div class="line">	if (xhr.readyState === 4) &#123;</div><div class="line">		if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123;</div><div class="line">			alert(xhr.responseText);</div><div class="line">		&#125;else&#123;</div><div class="line">			alert(&quot;error:&quot; + xhr.status)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&apos;get&apos;, demo.php, true);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure>
<h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h2><blockquote>
<p>CORS</p>
</blockquote>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/23/2016/2016-07-23-ajax笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016/2016-07-23-构造函数/" itemprop="url">
                  JavaScript 构造函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-23T14:36:00+08:00" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/23/2016/2016-07-23-构造函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/23/2016/2016-07-23-构造函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>能讲清楚你不会的知识，才代表正真学会了！</p>
</blockquote>
<h1 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h1><p><strong>简单的说就是一种创建对象的模式</strong></p>
<p>我们都知道在JavaScript 中 可以简单的用对象字面量来创建一个对象<code>person1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person1 = &#123;</div><div class="line">    name: &apos;lili&apos;,</div><div class="line">    say: function() &#123;</div><div class="line">        return &quot;I am &quot; + this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个<code>person1</code>有<code>name</code>属性，<code>say()</code>方法。但是假如有很多个人，他们都有<code>name</code>和<code>say()</code> 的属性和方法，也是说我们创建很多遍上面的代码，我的天这样的代码要写N遍，我要爆炸了。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/23/2016/2016-07-23-构造函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/fancyxi.png"
               alt="Fancyxi" />
          <p class="site-author-name" itemprop="name">Fancyxi</p>
          <p class="site-description motion-element" itemprop="description">能讲清楚你不会的知识，才代表正真学会了！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fancyfx" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/fangxi520" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="fangxi520@icloud.com" target="_blank" title="E-mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  E-mail
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fancyxi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fancyxi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
