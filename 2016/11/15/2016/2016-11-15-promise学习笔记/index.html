<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="异步操作," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="什么是Promise？  简单来说的Promise是一个异步处理规范，在JS中我们可以把他理解为一个异步处理函数，使用Promise规范的异步处理流程和方法来进行异步处理。目前Promise还在ES6 Promises规范草案阶段。
Promise浏览器兼容性
Promise主要API常用方法 promise.then() 和 promise.catch()  使用Promise简单的来说可以分为">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript异步操作之Promise学习笔记">
<meta property="og:url" content="https://fancyfx.github.io/2016/11/15/2016/2016-11-15-promise学习笔记/index.html">
<meta property="og:site_name" content="Fancyxi的博客">
<meta property="og:description" content="什么是Promise？  简单来说的Promise是一个异步处理规范，在JS中我们可以把他理解为一个异步处理函数，使用Promise规范的异步处理流程和方法来进行异步处理。目前Promise还在ES6 Promises规范草案阶段。
Promise浏览器兼容性
Promise主要API常用方法 promise.then() 和 promise.catch()  使用Promise简单的来说可以分为">
<meta property="og:image" content="https://fancyfx.github.io/img/Snip20161120_1.png">
<meta property="og:updated_time" content="2016-11-26T13:59:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript异步操作之Promise学习笔记">
<meta name="twitter:description" content="什么是Promise？  简单来说的Promise是一个异步处理规范，在JS中我们可以把他理解为一个异步处理函数，使用Promise规范的异步处理流程和方法来进行异步处理。目前Promise还在ES6 Promises规范草案阶段。
Promise浏览器兼容性
Promise主要API常用方法 promise.then() 和 promise.catch()  使用Promise简单的来说可以分为">
<meta name="twitter:image" content="https://fancyfx.github.io/img/Snip20161120_1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6278229309505144000,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://fancyfx.github.io/2016/11/15/2016/2016-11-15-promise学习笔记/"/>

  <title> JavaScript异步操作之Promise学习笔记 | Fancyxi的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Fancyxi的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-demo">
          <a href="/demo" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sticky-note"></i> <br />
            
            deom
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JavaScript异步操作之Promise学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-15T23:23:00+08:00" content="2016-11-15">
              2016-11-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/15/2016/2016-11-15-promise学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/15/2016/2016-11-15-promise学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h1><p>  简单来说的<code>Promise</code>是一个异步处理规范，在JS中我们可以把他理解为一个异步处理函数，使用Promise规范的异步处理流程和方法来进行异步处理。<br>目前<code>Promise</code>还在<a href="https://tc39.github.io/ecma262/#sec-promise-objects" target="_blank" rel="external">ES6 Promises</a>规范草案阶段。</p>
<h1 id="Promise浏览器兼容性"><a href="#Promise浏览器兼容性" class="headerlink" title="Promise浏览器兼容性"></a>Promise浏览器兼容性</h1><p><img src="/img/Snip20161120_1.png" alt="  浏览器兼容性"></p>
<h1 id="Promise主要API"><a href="#Promise主要API" class="headerlink" title="Promise主要API"></a>Promise主要API</h1><h2 id="常用方法-promise-then-和-promise-catch"><a href="#常用方法-promise-then-和-promise-catch" class="headerlink" title="常用方法 promise.then() 和 promise.catch()"></a>常用方法 <code>promise.then()</code> 和 <code>promise.catch()</code></h2><p>  使用Promise简单的来说可以分为三步</p>
<h3 id="①-通过new实例化Promise对象，并设置其值在-resolve-成功-reject-失败-时调用的回调函数"><a href="#①-通过new实例化Promise对象，并设置其值在-resolve-成功-reject-失败-时调用的回调函数" class="headerlink" title="① 通过new实例化Promise对象，并设置其值在 resolve(成功) / reject(失败)时调用的回调函数"></a>① 通过<code>new</code>实例化<code>Promise</code>对象，并设置其值在 resolve(成功) / reject(失败)时调用的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 要想创建一个promise对象、可以使用new来调用Promise的构造器来进行实例化。</div><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">    // 异步处理</div><div class="line">    // 处理结束后、调用resolve 或 reject</div><div class="line">    //对通过new生成的promise对象为了设置其值在 resolve(成功) / reject(失败)时调用的回调函数</div><div class="line">    if (err) &#123;</div><div class="line">      reject(&apos;error&apos;);</div><div class="line">    &#125;else&#123;</div><div class="line">      resolve(&apos;ok&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="②-如果成功-那么通过-promise-then-方法捕获成功的回调函数"><a href="#②-如果成功-那么通过-promise-then-方法捕获成功的回调函数" class="headerlink" title="② 如果成功 那么通过 promise.then()方法捕获成功的回调函数"></a>② 如果成功 那么通过 <code>promise.then()</code>方法捕获成功的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 如果成功 那么 promise.then()方法会执行</div><div class="line">promise.then(function(value)&#123;</div><div class="line">  console.log(value); // ok</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h3 id="③-如果失败-那么通过-promise-catch-方法捕获失败的回调函数"><a href="#③-如果失败-那么通过-promise-catch-方法捕获失败的回调函数" class="headerlink" title="③ 如果失败 那么通过 promise.catch()方法捕获失败的回调函数"></a>③ 如果失败 那么通过 <code>promise.catch()</code>方法捕获失败的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 如果失败 那么 promise.catch()方法会执行</div><div class="line">promise.catch(function(value)&#123;</div><div class="line">  console.log(value); // error</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="promise-then-实例方法的参数"><a href="#promise-then-实例方法的参数" class="headerlink" title="promise.then()实例方法的参数"></a><code>promise.then()</code>实例方法的参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<p><strong>resolve(成功)时</strong><br>onFulfilled 会被调用</p>
<p><strong>reject(失败)时</strong><br>onRejected 会被调用<br>onFulfilled、onRejected 两个都为可选参数。</p>
<p><strong>promise.then 成功和失败时都可以使用</strong>。<br><code>promise.then(undefined, onRejected)</code> 这种方式 等价于<code>promise.catch(onRejected)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//不使用catch 方法只使用 then方法的话,如下所示的代码也能完成相同的工作</div><div class="line">promise.then(function (value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;, function (error) &#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>不过大部分情况下使用 <code>promise.catch(onRejected)</code>处理异常 应该是个更好的选择。</p>
<h2 id="new-Promise的快捷方式"><a href="#new-Promise的快捷方式" class="headerlink" title="new Promise的快捷方式"></a>new Promise的快捷方式</h2><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a><code>Promise.resolve(value)</code></h3><p>静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。</p>
<p>比如 Promise.resolve(42); 可以认为是以下代码的语法糖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>方法 Promise.resolve(value); 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 .then 调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(42).then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Promise-reject-error"><a href="#Promise-reject-error" class="headerlink" title="Promise.reject(error)"></a><code>Promise.reject(error)</code></h3><p>Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">    reject(new Error(&quot;出错了&quot;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码的功能是调用该promise对象通过then指定的 onRejected 函数，并将错误（Error）对象传递给这个 onRejected 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.reject(new Error(&quot;BOOM!&quot;)).catch(function(error)&#123;</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p><code>Promise.all</code>接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 <code>.then</code> 方法。</p>
<p>如果像下面那样使用一个计时器来计算一下程序执行时间的话，那么就可以非常清楚的知道传递给 Promise.all 的promise数组是同时开始执行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// `delay`毫秒后执行resolve</div><div class="line">function timerPromisefy(delay) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(delay);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">var startDate = Date.now();</div><div class="line">// 所有promise变为resolve后程序退出</div><div class="line">Promise.all([</div><div class="line">    timerPromisefy(1),</div><div class="line">    timerPromisefy(32),</div><div class="line">    timerPromisefy(64),</div><div class="line">    timerPromisefy(128)</div><div class="line">]).then(function (values) &#123;</div><div class="line">    console.log(Date.now() - startDate + &apos;ms&apos;);</div><div class="line">    // 約128ms</div><div class="line">    console.log(values);    // [1,32,64,128]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>和 <code>Promise.all</code> 类似的对多个promise对象进行处理的 <code>Promise.race</code> 方法。</p>
<p>它的使用方法和P<code>romise.all</code>一样，接收一个promise对象数组为参数。</p>
<p><code>Promise.all</code> 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理， 与之相对的是 <code>Promise.race</code> 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
<p>像Promise.all时的例子一样，我们来看一个带计时器的 Promise.race 的使用例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// `delay`毫秒后执行resolve</div><div class="line">function timerPromisefy(delay) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(function () &#123;</div><div class="line">            resolve(delay);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// 任何一个promise变为resolve或reject 的话程序就停止运行</div><div class="line">Promise.race([</div><div class="line">    timerPromisefy(1),</div><div class="line">    timerPromisefy(32),</div><div class="line">    timerPromisefy(64),</div><div class="line">    timerPromisefy(128)</div><div class="line">]).then(function (value) &#123;</div><div class="line">    console.log(value);    // =&gt; 1</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>注意<code>Promise.race</code> 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</strong></p>
<h1 id="应用-XHR请求超时机制"><a href="#应用-XHR请求超时机制" class="headerlink" title="应用 XHR请求超时机制"></a>应用 XHR请求超时机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">// 虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是普通的错误还是超时错误了。</div><div class="line"></div><div class="line">// 为了能区分这个 Error 对象的类型，我们再来定义一个Error 对象的子类 TimeoutError。</div><div class="line">// ③定制Error对象</div><div class="line">function copyOwnFrom(target, source) &#123;</div><div class="line">    Object.getOwnPropertyNames(source).forEach(function (propName) &#123;</div><div class="line">        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));</div><div class="line">    &#125;);</div><div class="line">    return target;</div><div class="line">&#125;</div><div class="line">function TimeoutError() &#123;</div><div class="line">    var superInstance = Error.apply(null, arguments);</div><div class="line">    copyOwnFrom(this, superInstance);</div><div class="line">&#125;</div><div class="line">TimeoutError.prototype = Object.create(Error.prototype);</div><div class="line">TimeoutError.prototype.constructor = TimeoutError;</div><div class="line"></div><div class="line">// Promise.race 来是实现简单的超时机制</div><div class="line">// ①让Promise等待指定时间</div><div class="line">function delayPromise(ms) &#123;</div><div class="line">    return new Promise(function (resolve) &#123;</div><div class="line">        setTimeout(resolve, ms);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// ② Promise.race中的超时操作</div><div class="line">function timeoutPromise(promise, ms) &#123;</div><div class="line">    var timeout = delayPromise(ms).then(function () &#123;</div><div class="line">            return Promise.reject(new TimeoutError(&apos;Operation timed out after &apos; + ms + &apos; ms&apos;));</div><div class="line">        &#125;);</div><div class="line">    return Promise.race([promise, timeout]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过 cancelableXHR 方法取得包装了XHR的promise对象和取消该XHR请求的方法</div><div class="line">// ④ 通过超时取消XHR操作</div><div class="line">function cancelableXHR(URL) &#123;</div><div class="line">    var req = new XMLHttpRequest();</div><div class="line">    var promise = new Promise(function (resolve, reject) &#123;</div><div class="line">            req.open(&apos;GET&apos;, URL, true);</div><div class="line">            req.onload = function () &#123;</div><div class="line">                if (req.status === 200) &#123;</div><div class="line">                    resolve(req.responseText);</div><div class="line">                &#125; else &#123;</div><div class="line">                    reject(new Error(req.statusText));</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            req.onerror = function () &#123;</div><div class="line">                reject(new Error(req.statusText));</div><div class="line">            &#125;;</div><div class="line">            req.onabort = function () &#123;</div><div class="line">                reject(new Error(&apos;abort this request&apos;));</div><div class="line">            &#125;;</div><div class="line">            req.send();</div><div class="line">        &#125;);</div><div class="line">    var abort = function () &#123;</div><div class="line">        // 如果request还没有结束的话就执行abort</div><div class="line">        // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</div><div class="line">        if (req.readyState !== XMLHttpRequest.UNSENT) &#123;</div><div class="line">            req.abort();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return &#123;</div><div class="line">        promise: promise,</div><div class="line">        abort: abort</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var object = cancelableXHR(&apos;http://httpbin.org/get&apos;);</div><div class="line">// main</div><div class="line">timeoutPromise(object.promise, 1000).then(function (contents) &#123;</div><div class="line">    console.log(&apos;Contents&apos;, contents);</div><div class="line">&#125;).catch(function (error) &#123;</div><div class="line">    if (error instanceof TimeoutError) &#123;</div><div class="line">        object.abort();</div><div class="line">        return console.log(error);</div><div class="line">    &#125;</div><div class="line">    console.log(&apos;XHR Error :&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Promise的实现类库（Library）"><a href="#Promise的实现类库（Library）" class="headerlink" title="Promise的实现类库（Library）"></a>Promise的实现类库（Library）</h1><p>在这些Promise的实现类库中，我们这里主要对两种类型的类库进行介绍。</p>
<p>一种是被称为 Polyfill （这是一款英国产品，就是装修刮墙用的腻子，其意义可想而知 — 译者注）的类库，另一种是即具有 Promises/A+兼容性 ，又增加了自己独特功能的类库。</p>
<h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">jakearchibald/es6-promise</a></p>
<blockquote>
<p>一个兼容 ES6 Promises 的Polyfill类库。 它基于 RSVP.js 这个兼容 Promises/A+ 的类库， 它只是 RSVP.js 的一个子集，只实现了Promises 规定的 API。</p>
</blockquote>
<p><a href="https://github.com/yahoo/ypromise" target="_blank" rel="external">yahoo/ypromise</a></p>
<blockquote>
<p>这是一个独立版本的 YUI 的 Promise Polyfill，具有和 ES6 Promises 的兼容性。 本书的示例代码也都是基于这个 ypromise 的 Polyfill 来在线运行的。</p>
</blockquote>
<p><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="external">getify/native-promise-only</a></p>
<blockquote>
<p>以作为ES6 Promises的polyfill为目的的类库 它严格按照ES6 Promises的规范设计，没有添加在规范中没有定义的功能。 如果运行环境有原生的Promise支持的话，则优先使用原生的Promise支持。</p>
</blockquote>
<h2 id="Promise扩展类库"><a href="#Promise扩展类库" class="headerlink" title="Promise扩展类库"></a>Promise扩展类库</h2><p><a href="https://github.com/kriskowal/q" target="_blank" rel="external">kriskowal/q</a></p>
<blockquote>
<p>类库 <code>Q</code> 实现了 Promises 和 Deferreds 等规范。 它自2009年开始开发，还提供了面向Node.js的文件IO API Q-IO 等， 是一个在很多场景下都能用得到的类库。</p>
</blockquote>
<p><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">petkaantonov/bluebird</a></p>
<blockquote>
<p>这个类库除了兼容 Promise 规范之外，还扩展了取消promise对象的运行，取得promise的运行进度，以及错误处理的扩展检测等非常丰富的功能，此外它在实现上还在性能问题下了很大的功夫。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a>(首推 简单易懂 本文就是根据这本电子书的内容整理而成)<br><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">We have a problem with promises</a>（进阶）</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/异步操作/" rel="tag">#异步操作</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/09/2016/2016-08-09-javascript模块化/" rel="next" title="JavaScript模块化">
                <i class="fa fa-chevron-left"></i> JavaScript模块化
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/11/15/2016/2016-11-15-promise学习笔记/"
           data-title="JavaScript异步操作之Promise学习笔记" data-url="https://fancyfx.github.io/2016/11/15/2016/2016-11-15-promise学习笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/fancyxi.png"
               alt="Fancyxi" />
          <p class="site-author-name" itemprop="name">Fancyxi</p>
          <p class="site-description motion-element" itemprop="description">能讲清楚你不会的知识，才代表正真学会了！</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fancyfx" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/fangxi520" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="fangxi520@icloud.com" target="_blank" title="E-mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  E-mail
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是Promise？"><span class="nav-number">1.</span> <span class="nav-text">什么是Promise？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise浏览器兼容性"><span class="nav-number">2.</span> <span class="nav-text">Promise浏览器兼容性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise主要API"><span class="nav-number">3.</span> <span class="nav-text">Promise主要API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法-promise-then-和-promise-catch"><span class="nav-number">3.1.</span> <span class="nav-text">常用方法 promise.then() 和 promise.catch()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#①-通过new实例化Promise对象，并设置其值在-resolve-成功-reject-失败-时调用的回调函数"><span class="nav-number">3.1.1.</span> <span class="nav-text">① 通过new实例化Promise对象，并设置其值在 resolve(成功) / reject(失败)时调用的回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#②-如果成功-那么通过-promise-then-方法捕获成功的回调函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">② 如果成功 那么通过 promise.then()方法捕获成功的回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#③-如果失败-那么通过-promise-catch-方法捕获失败的回调函数"><span class="nav-number">3.1.3.</span> <span class="nav-text">③ 如果失败 那么通过 promise.catch()方法捕获失败的回调函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise-then-实例方法的参数"><span class="nav-number">3.2.</span> <span class="nav-text">promise.then()实例方法的参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-Promise的快捷方式"><span class="nav-number">3.3.</span> <span class="nav-text">new Promise的快捷方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-resolve-value"><span class="nav-number">3.3.1.</span> <span class="nav-text">Promise.resolve(value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-reject-error"><span class="nav-number">3.3.2.</span> <span class="nav-text">Promise.reject(error)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-all"><span class="nav-number">3.4.</span> <span class="nav-text">Promise.all</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-race"><span class="nav-number">3.5.</span> <span class="nav-text">Promise.race</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用-XHR请求超时机制"><span class="nav-number">4.</span> <span class="nav-text">应用 XHR请求超时机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise的实现类库（Library）"><span class="nav-number">5.</span> <span class="nav-text">Promise的实现类库（Library）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Polyfill"><span class="nav-number">5.1.</span> <span class="nav-text">Polyfill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise扩展类库"><span class="nav-number">5.2.</span> <span class="nav-text">Promise扩展类库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fancyxi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fancyxi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
